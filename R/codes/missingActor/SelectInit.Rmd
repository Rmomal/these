---
title: "Initial clique selection with vBIC criteria"
output: 
  html_document:
    toc: true
    toc_float: true
---

# Initialization

```{r}
seed=7
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=4, fig.height=4}
library(EMtree)
library(PLNmodels)
library(ggraph)
library(tidygraph)
library(tidyverse)
library(mvtnorm)
library(useful)
library(mclust)
library(MASS)
library(ROCR)
library(reshape2)#for ggimage
library(gridExtra)
library(kableExtra)
library(parallel)
library(sparsepca)
source("/Users/raphaellemomal/these/R/codes/missingActor/fonctions-missing.R")
#source("/home/mmip/Raphaelle/these/R/codes/missingActor/fonctions-missing.R")

# simu parameters
set.seed(seed) # mauvais 2, 4, 5 on a 2 lié à plein de gens donc pas trouvé et mauvais precrec H,
# 6 pas assez de voisins
n=200 ;p=14;r=1;type="scale-free";plot=TRUE
O=1:p

missing_data<-missing_from_scratch(n,p,r,type,plot)
counts=missing_data$Y
sigmaO= missing_data$Sigma
omega=missing_data$Omega
trueClique=missing_data$TC
hidden=missing_data$H

PLNfit<-PLN(counts~1)
MO<-PLNfit$var_par$M  
SO<-PLNfit$var_par$S  
sigma_obs=PLNfit$model_par$Sigma

clique_mclust=init.mclust((cov2cor(sigma_obs)),title="Sigma", nb.missing = r,
                          trueClique = trueClique,n.noise=3*p)
clique_mclust$init
computeFPN(res = clique_mclust,trueClique = trueClique)
plotInitMclust(res=clique_mclust,title = "")
init=initVEM(counts = counts, trueClique = trueClique,initviasigma=clique_mclust$init, sigma_obs,r = r)
Wginit= init$Wginit; Winit= init$Winit; omegainit=init$omegainit ; MHinit=init$MHinit

plot(sigmaO ,sigma_obs)
ome_init=omega[c(setdiff(1:(p+r), hidden), hidden),c(setdiff(1:(p+r), hidden), hidden)]
ome=ome_init ; diag(ome)=0
```


# Search of initial cliques:

Eigen vector space of Sigma: 

```{r}
init.mclust((cov2cor(sigma_obs)),title="Sigma",
            trueClique = trueClique,n.noise=3*p,plot = TRUE)$init
```

```{r,  message=FALSE}
B=50
List.init=vector(mode = "list")
c=1
for(i in 1:B){
  res<- init.mclust((cov2cor(sigma_obs)),title="Sigma",
                    trueClique = trueClique,n.noise=3*p,plot = FALSE)$init
  
  if(length(res)>1){
    print(res)
    List.init[[c]]<-res 
    c=c+1
  }
}
List.init<-unique(List.init)
List.init
N=setdiff(1:p,trueClique)
FP=unlist(lapply(List.init, function(init){sum(init%in%N)/length(N)}))
FN=unlist(lapply(List.init, function(init){sum(setdiff(1:p,init)%in%trueClique)/length(trueClique)}))

```


# Run of vBIC

```{r, message=FALSE}


vec.vBIC<-unlist(lapply(seq_along(List.init), function(num){
  cat(paste0("\n init ", num,"\n"))
  init<-List.init[[num]]
  initial.param<-initEM(sigma_obs,n=n,cliqueList = list(init),cst=1.05, pca=TRUE)  
  omega_init=initial.param$K0
  pr=prcomp(t(counts[,init]),scale. = FALSE)
  MHinit = matrix(pr$rotation[,1]*pr$sdev[1],nrow=n,ncol=r)
  
  vem<-VEMtree(counts,MO,SO,MH=MHinit,omega_init,W_init,Wg_init, eps=1e-2, 
               alpha=0.9,
               maxIter=30, plot=FALSE,vraiOm=ome_init,verbatim=FALSE,
               condTrack=FALSE,print.hist=FALSE)
  J1<-True_lowBound(counts,vem$M,vem$S, theta, matcovar,vem$W, vem$Wg, vem$Pg, vem$omega )
  vBIC<-VBIC(J1, ncol(counts),r=1, d=1, n=nrow(counts))
  return(vBIC)
}))

```



```{r, echo=FALSE}
data.frame(FP=round(FP,2), FN=round(FN, 2), vBIC=round(vec.vBIC, 2),crit=round(FP+FN,2),crit.rank=rank(FP+FN, ties.method = "min"), clique.size=unlist(lapply(List.init, length))) %>% 
  mutate(
    
    crit = cell_spec(crit, "html", bold = ifelse(crit==min(crit), T, F),
                     color = ifelse(crit==min(crit), "black", "red"))
    
  ) %>% 
  kable(format = "html", escape = F, align = "c") %>% 
  kable_styling(bootstrap_options = "striped")%>%
  row_spec(which.max(vec.vBIC), bold = F, color = "white", background = "#87AE7C")
```


# Robustness

On 20 scale-free graphs each with 15 tries for initialization.

```{r, cache=TRUE, echo=FALSE, message=FALSE,}

FitSparsePCA <- function(Y, q=1, alphaGrid=10^(seq(-4, 0, by=.1))){
  # Fit sparse PCA on a grid of alpha
  # Needs an estimate o Sigma: empirical variance of the rotated scores 
  #    + diagonal risidual variances (why not?)
  n <- nrow(Y); p <- ncol(Y); alphaNb <- length(alphaGrid); 
  # Fits all sparsePCA
  sPCA <- list()
  for(a in 1:alphaNb){
    sPCA[[a]] <- spca(Y, k=q, alpha=alphaGrid[a], verbose=FALSE)
    sPCA[[a]]$Sigma <- cov(sPCA[[a]]$scores%*%t(sPCA[[a]]$transform))
    
    resVar <- (n-1)*apply(Y - sPCA[[a]]$scores %*% t(sPCA[[a]]$transform), 2, var)/n
    sPCA[[a]]$Sigma <- sPCA[[a]]$Sigma  + diag(resVar)
    sPCA[[a]]$df <- 1 + sum(sPCA[[a]]$loadings!=0)
    sPCA[[a]]$loglik <- sum(dmvnorm((Y), sigma=sPCA[[a]]$Sigma, log=TRUE))
    sPCA[[a]]$bic <- sPCA[[a]]$loglik - log(n)*sPCA[[a]]$df/2
  }
  
  #2 neighbors minimum
  df<-unlist(lapply(sPCA, function(sPca){sPca$df}))
  good<-which(df>3)
  # Selects alpha via pseudo-BIC
  loglik <- unlist(lapply(sPCA, function(sPca){sPca$loglik}))
  bic <- unlist(lapply(sPCA, function(sPca){sPca$bic}))
  aOpt <- which.max(bic[good])
  # Find the cliques
  alphaOpt <- alphaGrid[aOpt]
  sPcaOpt <- sPCA[[aOpt]]
  sPcaOpt$loadings
  cliques <- list(); 
  sapply(1:ncol(sPcaOpt$loadings), function(j){
    cliques[[j]] <<- which(sPcaOpt$loadings[, j]!=0)
  })
  return(list(sPcaOpt=sPcaOpt, alphaGrid=alphaGrid, alphaOpt=alphaOpt, 
              loglik=loglik, bic=bic, cliques=cliques))
}

boot_FitSparsePCA<-function(Y, B){
  cliqueList<-lapply(1:B, function(x){
    n=nrow(Y); v=0.8; n.sample=round(0.8*n, 0)
    ech=sample(1:n,n.sample,replace = FALSE)
    Y.sample=Y[ech,]
    c=unlist(FitSparsePCA(Y.sample)$cliques)
    return(c)
  })
  cliqueList<-unique(cliqueList)
  return(cliqueList)
}
mclust.init<-function(sigma_obs, trueClique, B,n){
  List.init=vector(mode = "list")
  p=ncol(sigma_obs)
  c=1
  for(i in 1:B){
    res<- init.mclust((cov2cor(sigma_obs)),title="Sigma",
                      trueClique = trueClique,n.noise=3*p,plot = FALSE)$init[[1]]
    if(length(res)>=1){
      List.init[[c]]<-res
      c=c+1
    }
  }
  List.init<-unique(List.init)
  return(List.init)
}

varClust.init<-function(sigma_obs){
  vcPCA = F_VarClustPCA(sigma_obs)
  filter_content<-list()
  c=1
  lapply(seq_along(vcPCA$clustContent), function(x){
    if(length(vcPCA$clustContent[[x]])>2){
      filter_content[[c]]<<-vcPCA$clustContent[[x]]
      c<<-c+1
    } 
  })
  return(filter_content)
}
# vBIC computations
run.VEM<-function(init,counts,sigma_obs,MO,SO,W_init,Wg_init,r,ome_init){
  p=ncol(counts); O=1:p
  
  init=initVEM(counts = counts, initviasigma= list(init), sigma_obs=sigma_obs,r = r)
  omegainit=init$omegainit ; MHinit=init$MHinit
  alpha<-computeAlpha(omegainit[O,O], MO, SO, plot=FALSE)
  
  vem<-VEMtree(counts,MO,SO,MH=MHinit,omegainit,W_init,Wg_init, eps=1e-3,
               alpha=alpha,
               maxIter=30, plot=FALSE,vraiOm=ome_init,verbatim=FALSE,
               condTrack=FALSE,print.hist=FALSE, filterPg = TRUE)
  return(vem)
}
vec.vBIC<-function(List.vem,counts,theta, matcovar,r){
  
  n=nrow(counts);p= ncol(counts)
  unlist(lapply(List.vem,function(vem){
    J<-True_lowBound(counts,vem$M,vem$S, theta, matcovar,vem$W, vem$Wg, vem$Pg, vem$omega )
    vBIC<-VBIC(J,p,r=r, d=ncol(matcovar), n=n)
    return(vBIC)
  }))
}

run.method<-function(cliques,method,counts,sigma_obs,MO,SO,
                     Wginit, Winit, MHinit,ome_init,ome,r, theta, matcovar, trueClique ){
 
  p=ncol(counts)
  vem=lapply(cliques, function(init){
    run.VEM(init = init,counts=counts, sigma_obs,MO=MO, SO=SO, W_init=Winit, 
            Wg_init=Wginit, r=r, ome_init)
  })
  vec.perf<-data.frame(t(sapply(vem, function(x){
    auc=round(auc(pred = x$Pg, label = ome),4)
    h=(p+1):(p+r)
    PPVH=accppvtpr(x$Pg,ome,h=h,seuil=quantile(x$Pg[,h], 0.75))[5]
    return(c(auc=auc, PPVH=PPVH))
  })))
  vBIC<-vec.vBIC(vem,counts,theta, matcovar, r=r)
  best=which.max(vBIC)
  data=computeFPN(cliques, trueClique, p) %>% 
    mutate( vBIC=vBIC, sizes=unlist(lapply(cliques, length)),
            auc=vec.perf$auc, PPVH=vec.perf$PPVH,method=c(method))
  choice=data[best,]
  return(choice)
}
SelectInitClique<-function(seed, B, n=200, p=14, r=1){
  
  cat(paste0("\n seed ",seed, "\n"))
  set.seed(seed)
  type="scale-free" ;O=1:p;plot=FALSE
  
  missing_data<-missing_from_scratch(n,p,r,type,plot)
  counts=missing_data$Y; sigmaO= missing_data$Sigma; omega=missing_data$Omega;
  trueClique=missing_data$TC[[1]]; hidden=missing_data$H
  PLNfit<-PLN(counts~1)
  MO<-PLNfit$var_par$M  ; SO<-PLNfit$var_par$S  ; theta=PLNfit$model_par$Theta ; 
  matcovar=matrix(1, n,1) ; sigma_obs=PLNfit$model_par$Sigma
  init=initVEM(counts = counts, initviasigma = trueClique,  sigma_obs,r = r)
  Wginit= init$Wginit; Winit= init$Winit; omegainit=init$omegainit ; MHinit=init$MHinit
  ome_init=omega[c(setdiff(1:(p+r), hidden), hidden),c(setdiff(1:(p+r), hidden), hidden)]
  ome=ome_init ; diag(ome)=0
  
  #true perfs
  vem=run.VEM(init = trueClique[[1]],counts=counts, sigma_obs, MO=MO, SO=SO, 
              W_init=Winit, Wg_init=Wginit, r=r, ome_init)
  truevBIC= vec.vBIC(list(vem), counts=counts, theta, matcovar, r=r)
  true.perf<-data.frame(t(sapply(list(vem), function(x){
    auc=round(auc(pred = x$Pg, label = ome),4)
    h=(p+1):(p+r)
    PPVH=accppvtpr(x$Pg,ome,h=h,seuil=quantile(x$Pg[,h], 0.75))[5]
    return(c(auc=auc, PPVH=PPVH))
  })))
  
  #=== MCLUST
  cat(paste0("\n ------ MCLUST ------ \n"))
  cliques_mclust<-mclust.init(sigma_obs, trueClique[[1]],B, n)
  vem_mclust=lapply(cliques_mclust, function(init){
    run.VEM(init = init,counts=counts,sigma_obs, MO=MO, SO=SO, W_init=Winit, Wg_init=Wginit, r=r,ome_init)
  })
  vec.perf<-data.frame(t(sapply(vem_mclust, function(x){
    auc=round(auc(pred = x$Pg, label = ome),4)
    h=(p+1):(p+r)
    PPVH=accppvtpr(x$Pg,ome,h=h,seuil=quantile(x$Pg[,h], 0.75))[5]
    return(c(auc=auc,PPVH= PPVH))
  })))
  vBIC_mclust<-vec.vBIC(vem_mclust,counts,theta, matcovar, r=r)
  FPN_mclust<-computeFPN(cliques_mclust, trueClique, p)
  data=FPN_mclust %>% mutate(crit=FP+FN, crit.rank=rank(crit, ties.method = "min"),
                             vBIC=vBIC_mclust,sizes=unlist(lapply(cliques_mclust, length)),
                             auc=vec.perf$auc, PPVH=vec.perf$PPVH)
  mclust.choice<-data[which.max(data$vBIC),-c(3, 4)]
  mclust.choice$method="mclust"
  data3<-data %>% filter(sizes>3) %>% dplyr::select(-crit, -crit.rank)
  if(nrow(data3)!=0){
    mclust.choice.min3<- data3%>% filter(vBIC==max(vBIC))  
    mclust.choice.min3$method="mclust.min3"
    mclust.choice<-rbind(mclust.choice,mclust.choice.min3)
  }
  #---
  
  #=== sPCA
  cat(paste0("\n ------ sPCA ------ \n"))
  cat(paste0("\n sPCA.Y \n"))
  cliques_spcaY <- boot_FitSparsePCA(scale(counts),B)
    cat(paste0("\n sPCA.Z \n"))
  cliques_spcaZ <- boot_FitSparsePCA(scale(MO),B)
    cat(paste0("\n run sPCA.Y \n"))
  spcaY.choice=run.method(cliques_spcaY,"spca.Y",counts,sigma_obs,MO,SO,
                     Wginit, Winit, MHinit,ome_init,ome,r, theta, matcovar, trueClique )
    cat(paste0("\n run sPCA.Z \n"))
  spcaZ.choice=run.method(cliques_spcaZ,"spca.Z",counts,sigma_obs,MO,SO,
                     Wginit, Winit, MHinit,ome_init,ome,r, theta, matcovar, trueClique )
  #---
  
  #=== varClust
  cat(paste0("\n ------ VarClust ------ \n"))
  cliques_varclust<-varClust.init(sigma_obs)
  cat(paste0("\n run varClust \n"))
  varclust.choice<-run.method(cliques_varclust,"VarClust",counts,sigma_obs,MO,SO,
                     Wginit, Winit, MHinit,ome_init,ome,r, theta, matcovar, trueClique )
  #---
  choices<-rbind(spcaY.choice, spcaZ.choice, mclust.choice , varclust.choice,
                 data.frame(FP=0,FN=0, vBIC=truevBIC,sizes=length(trueClique), 
                            auc=true.perf$auc,PPVH=true.perf$PPVH,  method="Truth"))
  choices$seed=seed
  cat(paste0("\n end choice \n"))
  
  return(list(choice=choices))
}

seed=1:200
t1<-Sys.time()
res<-mclapply(seed, function(x){ SelectInitClique(x, B=30)}, mc.cores=1)
t2<-Sys.time()
difftime(t2, t1)

saveRDS(object = res, file = "/Users/raphaellemomal/simulations/Simu/selectInit.rds" )
# rank.size<-unlist(lapply(res, function(x){rank(x$perf$clique.size)}))
# rank.crit<-unlist(lapply(res, function(x){ x$perf$crit.rank}))
# plot(rank.crit, rank.size)
# quality<-unlist(lapply(res, function(x){x$quality}))
# quality %>% as_tibble() %>% ggplot(aes(value, y=..prop..))+geom_bar(width=0.5, alpha=0.6, fill="deepskyblue3")+mytheme+labs(x="rank of FN+FP", y="choice with max vBIC")

quality<-do.call(rbind,lapply(res, function(x){x$choice}))

 
test=quality %>% dplyr::select(-FN, -FP, -auc, -vBIC, -PPVH) %>% spread(method, sizes) %>%dplyr::select(Truth) 
truthSizes=sort(unique(test$Truth), decreasing = FALSE)
lapply(truthSizes, function(x){
  which(test$Truth==x)
})
#filter by the number of original neighbors
  index=which(test$Truth>2)
# FPN
p1<-quality %>% filter(method!="Truth") %>%  
  gather(key, value, -method, -sizes, -vBIC, -seed) %>%  
   mutate(method = fct_relevel(method, 
            "VarClust","mclust","spca.Z","mclust.min3","spca.Y")) %>% 
  ggplot(aes(as.factor(method), value, color=as.factor(key),fill=as.factor(key)))+
  geom_hline(yintercept = 0.5, linetype="dashed")+
  geom_boxplot(alpha=0.3, width=0.6) +theme_light()+labs(x="",y="",title="On 200 scale-free graphs")+
  scale_color_hp_d("",option = "Gryffindor")+
  scale_fill_hp_d("",option = "Gryffindor")
# AUC PPVH
quality %>% filter(method!="Truth") %>% gather(key, value, -method, -sizes, -vBIC, -seed,-FN, -FP) %>%
  ggplot(aes(as.factor(method), value, color=as.factor(key),fill=as.factor(key)))+
  geom_boxplot(alpha=0.3) +theme_light()+labs(x="",y="",title="On 200 scale-free graphs")+
  scale_color_hp_d("",option = "Gryffindor")+
  scale_fill_hp_d("",option = "Gryffindor")
test=quality %>% filter(method!="Truth")%>% dplyr::select(-FN, -FP, -sizes, -vBIC, -PPVH) %>% spread(method, auc)
AUCranks<-t(apply(test[,-1],1,function(x){
  rank(x, ties.method = "max")
}))
AUCranks %>%as_tibble() %>%  gather(key, value) %>% 
  ggplot(aes( x=value, y=..prop..,color=key, fill=key ))+
  geom_bar(position = position_dodge(),width = 0.7)+#stat="binline",bins=14, scale=0.8, draw_baseline=FALSE)
  theme_light()+labs(x="",y="",title="AUC ranks (max is best)")+
  scale_color_hp_d("",option = "Ravenclaw")+ scale_fill_hp_d("",option = "Ravenclaw")

# Sizes
quality %>%  
  ggplot(aes( sizes, y=..prop.., color=method, fill=method ))+
  geom_bar() +theme_light()+labs(x="",y="",title="Size of found cliques compared to truth")+
  scale_color_hp_d("",option = "Ravenclaw")+scale_fill_hp_d("",option = "Ravenclaw")

p2<-quality %>%  
  ggplot(aes( x=as.numeric(sizes), y=method,color=method, fill=method ))+
  geom_density_ridges()+#stat="binline",bins=14, scale=0.8, draw_baseline=FALSE)
  theme_light()+labs(x="",y="",title="Size of found cliques compared to truth")+
  scale_color_hp_d("",option = "Ravenclaw")+ scale_fill_hp_d("",option = "Ravenclaw")

# Gap in vBIC
test=quality %>% dplyr::select(-FN, -FP, -sizes, -auc, -PPVH) %>% spread(method, vBIC)
vBICdiff<-apply(test[,-c(1,ncol(test))],2,function(x){
  x-test$Truth
})
vBICdiff %>%as_tibble() %>%  gather(key, value) %>% 
  ggplot(aes( x=key, y=value,color=key, fill=key ))+
  geom_boxplot(width=0.4)+#stat="binline",bins=14, scale=0.8, draw_baseline=FALSE)
  theme_light()+labs(x="",y="",title="vBIC - trueVBIC")+
  geom_hline(yintercept = 0, linetype="dashed")+
  scale_color_hp_d("",option = "Ravenclaw")+ scale_fill_hp_d("",option = "Ravenclaw")+ coord_flip()

# Best vBic in rank
vBICranks<-t(apply(test[,-c(1,ncol(test))],1,function(x){
  rank(x, ties.method = "max")
}))
p3<-vBICranks %>%as_tibble() %>%  gather(key, value) %>% 
  ggplot(aes( x=value, y=..prop..,color=key, fill=key ))+
  geom_bar(position = position_dodge(),width = 0.7)+#stat="binline",bins=14, scale=0.8, draw_baseline=FALSE)
  theme_light()+labs(x="",y="",title="vBIC ranks (max is best)")+
  scale_color_hp_d("",option = "Ravenclaw")+ scale_fill_hp_d("",option = "Ravenclaw")


plot=grid.arrange(p1, p2, p3, ncol=1)
ggsave(filename = "selectInit_final.png", plot = p1, path ="/Users/raphaellemomal/these/R/images/", width = 7, height = 4 )
```

