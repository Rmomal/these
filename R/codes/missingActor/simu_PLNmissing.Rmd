---
title: "SimuPLNmissing"
output: 
  html_document:
    toc: true
    toc_float: true
---
```{r, message=FALSE}
library(PLNmodels)
library(EMtree)
library(LITree)
library(mvtnorm)
library(MASS)
library(saturnin)
library(Matrix)
library(ggplot2)
library(tictoc)
library(tibble)
library(ROCR)
library(mclust)
library(useful)
library(dplyr)
library(rlist)
library(tidyr)
source('/Users/raphaellemomal/these/R/codes/missingActor/LiTree/functions-estimation.R')
source('/Users/raphaellemomal/these/R/codes/missingActor/LiTree/functions-simulation.R')
```

```{r, echo=FALSE}
F_Vec2Sym <- function(A.vec){
  n = (1+sqrt(1+8*length(A.vec)))/2
  A.mat = matrix(0, n, n)
  A.mat[lower.tri(A.mat)] = A.vec
  A.mat = A.mat + t(A.mat)
  return(A.mat)
}
F_Sym2Vec <- function(A.mat){
  return(A.mat[lower.tri(A.mat)])
}

#EMtree from a covariance matrix instead of a PLN object
EMtree_corZ<-function(CovZ,n,  maxIter=30, cond.tol=1e-10, verbatim=TRUE, plot=FALSE){
  CorZ=cov2cor(CovZ)
  p = ncol(CorZ)
  alpha.psi = Psi_alpha(CorZ, n, cond.tol=cond.tol)
  psi = alpha.psi$psi
  beta.unif = matrix(1, p, p); diag(beta.unif) = 0; beta.unif = beta.unif / sum(beta.unif)
  FitEM = FitBetaStatic(beta.init=beta.unif, psi=psi, maxIter = maxIter,
                        verbatim=verbatim, plot=plot)
  return(FitEM)
}

init.mclust<-function(S,nb.missing=1, n.noise=50,plot=TRUE, title="",trueClique=NULL){
  X<-data.frame(t(t(eigen(S)$vectors[,1:2])*sqrt(eigen(S)$values[1:2])))
  
  p=nrow(X)+nb.missing
  b=apply(X, 2, range)
  poissonNoise<-apply(b, 2, function(x,n=n.noise){
    runif(n,min=x[1]-0.1, max=x[2]+0.1)
  })
  data=rbind(X, poissonNoise)
  noiseInit<-sample(c(T,F), size=nrow(X)+n.noise, replace=T, prob=c(3, 1))
  
  datapolar=cart2pol(x=data[,1],y=data[,2])[,1:2]
  datapolar=datapolar %>% mutate(theta2=ifelse(theta>pi,theta-pi,theta)) %>% select(r,theta2)
  newdata=pol2cart(datapolar$r,datapolar$theta2)[,1:2]
  
  clust=Mclust(data=newdata,initialization = list(noise=noiseInit),G=nb.missing)
  groups<-map(clust$z)
  res<-which(groups==1)[which(groups==1)<=nrow(X)] 
  if(plot){
    if(!is.null(trueClique)){
      #False positives rate
      N=setdiff(1:p,trueClique)
      FP=sum(res%in%N)/length(N)
      # False negatives rate
      FN=sum(setdiff(1:p,res)%in%trueClique)/length(trueClique)
      title=paste0(title,":"," FN=", round(FN,2),",FP=",round(FP,2))
    }
    
    g= ggplot(X,aes(X1,X2, label=rownames(X),color=rownames(X)%in%res))+geom_point(size=0.1)+
      theme_light()+geom_text()+labs(x="eig vect 1",y="eig vect 2", title=title)+
      guides(color=FALSE)+scale_color_brewer(palette="Dark2")+
      geom_hline(yintercept=0, color="gray50")+geom_vline(xintercept=0, color="gray50")
    print(g)
  }
  return(res)
}
fun.auc.ggplot <- function(Listpred, obs, title, matrix=TRUE){
  #require(ROCR)
  if(matrix){
    indices_nuls<-which(obs==0)
    label<-matrix(1,nrow=nrow(obs),ncol=ncol(obs))
    label[indices_nuls]<-0
  }
  
  ROC_auc=c()
  plotdat=lapply(seq_along(Listpred),function(x){
    pred=Listpred[[x]]
    if(matrix){
      prediction<-prediction(as.vector(pred[upper.tri(pred)]),as.vector(label[upper.tri(label)]))
      obs<-as.vector(label[upper.tri(label)])
    }else{
      prediction<-prediction(pred$prediction, pred$label)
      obs<-pred$label
    }
    
    # Run the AUC calculations
    ROC_perf <- performance(prediction,"tpr","fpr")
    
    ROC_auc <<-c(ROC_auc, round(performance(prediction,"auc")@y.values[[1]],digits=2))
    
    # Make plot data
    res <- data.frame(FP=ROC_perf@x.values[[1]],TP=ROC_perf@y.values[[1]], method=names(Listpred)[x] )
    
  })
  plotdat=do.call(rbind, plotdat)
  # Plot the curve
  
  ggplot(plotdat, aes(x=FP,y=TP)) +
    geom_abline(intercept=0,slope=1,linetype="dashed",color="grey") +
    geom_line(aes(color=method)) +
    scale_x_continuous("False Positive Rate", limits=c(0,1)) +
    scale_y_continuous("True Positive Rate", limits=c(0,1)) +
    geom_polygon(aes(x=X,y=Y), data=data.frame(X=c(0.75,1,1,0.75),Y=c(0,0,0.2,0.2)), fill="white") +
    annotate("text",x=0.97,y=0.2,label=paste0("AUC: "),hjust=1) +
    annotate("text",x=0.97,y=0.15,label=paste0(names(Listpred)[1],": ",ROC_auc[1]),hjust=1) +
    annotate("text",x=0.97,y=0.1,label=paste0(names(Listpred)[2],": ",ROC_auc[2]),hjust=1) +
    annotate("text",x=0.97,y=0.05,label=paste0(names(Listpred)[3],": ",ROC_auc[3]),hjust=1) +
    theme(legend.position="none", plot.title=element_text(vjust=2,hjust = 0.5)) +
    labs(title=title)+
    theme_bw()
}

compute_nSNR<-function(K, indexmissing){
  H=indexmissing ; p=ncol(K)
  O=(1:p)[-H]
  num=norm(K[O,H]%*%solve(K[O,O])%*%K[H,O],type='F')^2
  denom=(K[H,H])^2
  return(num/denom)
}
compute_SNR<-function(K, indexmissing){
  H=indexmissing ; p=ncol(K)
  O=(1:p)[-H]
  num=norm(K[O,H]%*%K[H,O]/K[H,H],type='F')^2
  denom=norm(K[O,O],type='F')^2
  return(num/denom)
}
amplify_cor<-function(K,indexmissing,eps){
  H=indexmissing ; p=ncol(K)
  O=(1:p)[-H]
  newK=eps*K
  newK[O,O]=K[O,O]
  newK[H,H]=eps*K[H,H]
  return(newK)
}
amplify_diag<-function(K,v){
  newK<-K+diag(v, ncol(K))
  return(newK)
}
setEpsi<-function(K,indexmissing, plot=FALSE){
  eps<-1
  v<-0
  L=list(c(compute_SNR(K,indexmissing),eps,v))
  print(min(eigen(K)$values))
  newK=K
  while(compute_SNR(newK,indexmissing)<2 ){
    # cat(paste0("\n min eig",min(eigen(K)$values),", eps",eps,",v",v))
    
    if(min(eigen(newK)$values)>0){
      while(min(eigen(newK)$values)>0){
        eps=eps+0.01
        newK=amplify_cor(K,indexmissing,eps)
      }
      cat(paste0("\n SNR=",round(compute_SNR(newK,indexmissing),2),", mineig=",round(min(eigen(newK)$values),2),", eps=",eps,", v=",v))
      L=list.append(L,c(compute_SNR(newK,indexmissing), eps, v))
    }else{
      while(min(eigen(newK)$values)<=0){
        v=v+0.01
        newK=amplify_diag(K,v)
      }
      cat(paste0("\n SNR=",round(compute_SNR(newK,indexmissing),2),", mineig=",round(min(eigen(newK)$values),2),", eps=",eps,", v=",v))
      L=list.append(L,c(compute_SNR(newK,indexmissing), eps, v))
    }
  }
  while(min(eigen(newK)$values)<=0){
    v=v+0.001
    K=amplify_diag(K,v)
  }
  L=list.append(L,c(compute_SNR(newK,indexmissing), eps, v))
  
  L=do.call(rbind,L)
  colnames(L)=c("SNR","Epsilon","Lambda")
  cat(paste0("\nfinal SNR=",round(compute_SNR(newK,indexmissing),3)," and final min eig=", round(min(eigen(newK)$values),3),", for eps=",eps," and v=",v))
  if(plot){
    g= L%>% as_tibble() %>% gather(parameter,value,-SNR) %>% 
      ggplot(aes(value,SNR))+geom_point()+geom_line()+facet_wrap(~parameter,scales="free")+
      theme_light()
    print(g)
  }
  return(list(K=K,values=L))
}

gener.data<-function(p=20,n=200,counts=FALSE, type="starerdos", v=0.001,plot=TRUE,prop=10/p){
  #  data=data_from_scratch(type = type,p = p,n = n,signed = FALSE,prob = 5/p,v = v)
  
  
  #hidden=which.max(diag(omega)) #on cache le noeud de plus fort degré
  star.graph <- graphModel$new(type = type,size=p, p.or.m = prop)
  star.model <- GGMmodel$new(graph=star.graph,nb.missing.var= 1)
  adjmat=star.model$getAdjmat()
  hidden=star.model$missing.var.list
  
  #omega=covarianceFromGraph(adjmat,missing.var.list = hidden,
   #                         method="raph",prop.positive.cor = 0 ,
   #                         alpha.hidden = 1, alpha.observed = 1.5)
  omega=star.model$K
  # omega=data$omega
  sigma=star.model$Sigma
   Kh  <- omega[hidden,hidden]
    Ko  <- omega[-hidden,-hidden]
    Koh <- omega[-hidden,hidden]
    Km  <- Ko - Koh %*%solve(Kh)%*% t(Koh)
    cat(paste0("\ndistance Km-Ko = ",mean((Km-Ko)^2)))
    #  K  <- params
  # les voisins du noeuds qu'on cache
  trueClique=which(omega[hidden,-hidden]!=0)
  
  #comptages ou non
  if(counts){
    counts=generator_PLN(sigma,covariates = NULL,n=n)
    counts_obs=counts[,-hidden]
    sigma_obs=PLN(counts_obs~1)$model_par$Sigma
    # les résultats $get... de LITree ne suffisent pas pour PLN
  }else{
    data=rmvnorm(n,sigma=sigma)
    data_obs=data[,-hidden]
    sigma_obs=cov(data_obs)
    # sigma_obs=star.model$getAdjmatMarg()
  }
  omega_obs=solve(sigma_obs)
  if(plot){
    G=draw_network(adjmat,groupes=1*(diag(omega)==diag(omega)[hidden]), 
                   layout="nicely",curv=0,nb=2,pal="black",nodes_label = 1:p)$G
    print(G)
  }
  return(list(sigmaO=sigma_obs, omegaO=omega_obs,omega=omega,clique=trueClique, hidden=hidden))
}
```

# Data

Data is generated according to an underlying graphical model. The precision matrix is built on the adjacency matrix, then the most connected node is hidden. A control on the Signal/Noise ratio (SNR) is done likewise in Robin et.al, which tunes parameters $\epsilon$ and $\lambda$ to ensure a SNR value of about 1, and a positive-difinite precision matrix.

```{r Data}
set.seed(7)
p=30
n=300
Data=gener.data(counts = FALSE,p=p,n=n,type="erdos",prop=5/p)
omega=Data$omega
adjmat=1*(omega!=0)
omega_obs=Data$omegaO
sigma_obs=Data$sigmaO
trueClique=Data$clique
compute_SNR(omega,Data$hidden)
min(eigen(omega)$values)
```

```{r}
FitBetaStatic()
```



# Initialization

The function `init.mclust` takes the covariance matrix as input, and apply a model of mclust which uses some background noise. That way, we can look for a cluster without forcing the rest of the data to form a second cluster. 
The clustering is done on the space built with the first two eigen vectors of the covariance matrix. To solve the issue of the sign in this particular space, points are converted in polar coordinates and recoded with $\theta \in [0,\pi]$ an $\rho$ real valued.


```{r init1}
initviasigma=init.mclust(sigma_obs,title="Sigma",trueClique = trueClique,n.noise=p*3+5)
initviaomega= init.mclust(omega_obs,title="Omega",trueClique = trueClique,n.noise=p*3+5)
trueClique
```

We choose to initialize from omega

We design two types of initialization, one using `mclust` and another using function `findCliques`

```{r init2}
sample=FALSE
boolomega=FALSE
if(length(initviasigma)<3) boolomega=TRUE
if(length(initviasigma)<3 && length(initviaomega)<3){sample=TRUE; boolomega=FALSE} 
init1=list(initviasigma)
if(boolomega) init1=list(initviaomega)
if(sample){
  init1=list(order(colSums(sigma_obs),decreasing=TRUE)[1:3])
  print(init1)
} 
init2=findCliques(sigma_obs,1)

initial.param<-initEM(sigma_obs,n=n,cliquelist = init2,pca=TRUE)
K2=initial.param$K0
Sigma2=initial.param$Sigma0


initial.param<-initEM(sigma_obs,n=n,cliquelist = init1,pca=TRUE)
K1=initial.param$K0
Sigma1=initial.param$Sigma0
```

# Inferences

The network is inferred using the `treeAgr.EM`function of Robin et. al 2018 (recoded as `EMtreeMissing`). The two different initializations are tested, as well as a "naive"" version of EMtree, which is EMtree run on a covariance matrix which consists in the observed covariance matrix with an additional dimension and "1" on the diagonal (0 elsewhere on the added dimension row and column).

```{r inferences, message=FALSE,warning=FALSE}
tic()
inftreeAgr1 = EMtreeMissing(S=sigma_obs, k=1, K0 = K1, Sigma0 = Sigma1, pii=0.5, n=n,
                            max.iter = 200, eps = 0.1,method = "saturnin")  
toc()

tic()
inftreeAgr2 = EMtreeMissing(S=sigma_obs, k=1, K0 = K2, Sigma0 = Sigma2, pii=0.5, n=n,
                            max.iter = 200, eps = 0.1,method = "saturnin")  
toc()


```

```{r plotlik, echo=FALSE, warning=FALSE}
lik1=inftreeAgr1$likelihoods[1:(which.min(inftreeAgr1$likelihoods!=0)-1)]
lik2=inftreeAgr2$likelihoods[1:(which.min(inftreeAgr2$likelihoods!=0)-1)]

data.frame(inf1=c(lik1,rep(NaN,max(length(lik1),length(lik2))-length(lik1))), 
           inf2=c(lik2,rep(NaN,max(length(lik1),length(lik2))-length(lik2)))) %>% 
  rowid_to_column() %>% gather(inf,lik,-rowid) %>% 
  ggplot(aes(rowid,lik,color=inf))+geom_point()+geom_line()+theme_light()+facet_wrap(~inf, scales="free")+guides(color=FALSE)
```

```{r}

# EMtree : proba calculées à partir du Sigma reconstitué par treeAgrEM
# EMtree naif: ajout d'une ligne et colonne à sigma_obs, avec 1 sur la diagonale
infEMtree=EMtree_corZ(CovZ=inftreeAgr1$Sigma,n = n)$edges_prob
infEMtreeNaif=EMtree_corZ(CovZ=rbind(cbind(sigma_obs,rep(0,p-1)),c(rep(0,p-1),1)),n = n)$edges_prob

```


# Results

```{r results}
probdata=data.frame("sat1"=F_Sym2Vec(inftreeAgr1$alpha),
                    "sat2"=F_Sym2Vec(inftreeAgr2$alpha),
                    "EMtree"=F_Sym2Vec(infEMtree),
                    "EMtreeNaif"=F_Sym2Vec(infEMtreeNaif))

probdata %>%as_tibble() %>% 
  ggplot(aes(sat1,sat2, color=EMtreeNaif))+geom_point()+theme_light()


fun.auc.ggplot(Listpred = list( EMtreeNaif=infEMtreeNaif,#EMtree=infEMtree,
                                saturnin1=inftreeAgr1$alpha,
                                saturnin2=inftreeAgr2$alpha),
               obs=omega, title="")


```

# Used functions

```{r}
F_Vec2Sym <- function(A.vec){
  n = (1+sqrt(1+8*length(A.vec)))/2
  A.mat = matrix(0, n, n)
  A.mat[lower.tri(A.mat)] = A.vec
  A.mat = A.mat + t(A.mat)
  return(A.mat)
}
F_Sym2Vec <- function(A.mat){
  return(A.mat[lower.tri(A.mat)])
}

#EMtree from a covariance matrix instead of a PLN object
EMtree_corZ<-function(CovZ,n,  maxIter=30, cond.tol=1e-10, verbatim=TRUE, plot=FALSE){
  CorZ=cov2cor(CovZ)
  p = ncol(CorZ)
  alpha.psi = Psi_alpha(CorZ, n, cond.tol=cond.tol)
  psi = alpha.psi$psi
  beta.unif = matrix(1, p, p); diag(beta.unif) = 0; beta.unif = beta.unif / sum(beta.unif)
  FitEM = FitBetaStatic(beta.init=beta.unif, psi=psi, maxIter = maxIter,
                        verbatim=verbatim, plot=plot)
  return(FitEM)
}

init.mclust<-function(S,nb.missing=1, n.noise=50,plot=TRUE, title="",trueClique=NULL){
  X<-data.frame(t(t(eigen(S)$vectors[,1:2])*sqrt(eigen(S)$values[1:2])))
  
  p=nrow(X)+nb.missing
  b=apply(X, 2, range)
  poissonNoise<-apply(b, 2, function(x,n=n.noise){
    runif(n,min=x[1]-0.1, max=x[2]+0.1)
  })
  data=rbind(X, poissonNoise)
  noiseInit<-sample(c(T,F), size=nrow(X)+n.noise, replace=T, prob=c(3, 1))
  datapolar=cart2pol(x=data[,1],y=data[,2])[,1:2]
  datapolar=datapolar %>% mutate(theta2=ifelse(theta>pi,theta-pi,theta)) %>% select(r,theta2)
  newdata=pol2cart(datapolar$r,datapolar$theta2)[,1:2]
  clust=Mclust(data=newdata,initialization = list(noise=noiseInit),G=nb.missing)
  groups<-map(clust$z)
  res<-which(groups==1)[which(groups==1)<=nrow(X)] 
  if(plot){
    if(!is.null(trueClique)){
      #False positives rate
      N=setdiff(1:p,trueClique)
      FP=sum(res%in%N)/length(N)
      # False negatives rate
      FN=sum(setdiff(1:p,res)%in%trueClique)/length(trueClique)
      title=paste0(title,":"," FN=", round(FN,2),",FP=",round(FP,2))
    }
    
    g= ggplot(X,aes(X1,X2, label=rownames(X),color=rownames(X)%in%res))+geom_point(size=0.1)+
      theme_light()+geom_text()+labs(x="eig vect 1",y="eig vect 2", title=title)+
      guides(color=FALSE)+scale_color_brewer(palette="Dark2")+
      geom_hline(yintercept=0, color="gray50")+geom_vline(xintercept=0, color="gray50")
    print(g)
  }
  return(res)
}
fun.auc.ggplot <- function(Listpred, obs, title){
  #require(ROCR)
  indices_nuls<-which(obs==0)
  label<-matrix(1,nrow=nrow(obs),ncol=ncol(obs))
  label[indices_nuls]<-0
  ROC_auc=c()
  plotdat=lapply(seq_along(Listpred),function(x){
    pred=Listpred[[x]]
    prediction<-prediction(as.vector(pred[upper.tri(pred)]),as.vector(label[upper.tri(label)]))
    obs<-as.vector(label[upper.tri(label)])
    # Run the AUC calculations
    ROC_perf <- performance(prediction,"tpr","fpr")
    
    ROC_auc <<-c(ROC_auc, round(performance(prediction,"auc")@y.values[[1]],digits=2))
    
    # Make plot data
    res <- data.frame(FP=ROC_perf@x.values[[1]],TP=ROC_perf@y.values[[1]], method=names(Listpred)[x] )
    
  })
  plotdat=do.call(rbind, plotdat)
  # Plot the curve
  
  ggplot(plotdat, aes(x=FP,y=TP)) +
    geom_abline(intercept=0,slope=1,linetype="dashed",color="grey") +
    geom_line(aes(color=method)) +
    scale_x_continuous("False Positive Rate", limits=c(0,1)) +
    scale_y_continuous("True Positive Rate", limits=c(0,1)) +
    geom_polygon(aes(x=X,y=Y), data=data.frame(X=c(0.75,1,1,0.75),Y=c(0,0,0.2,0.2)), fill="white") +
    annotate("text",x=0.97,y=0.2,label=paste0("AUC: "),hjust=1) +
    annotate("text",x=0.97,y=0.15,label=paste0(names(Listpred)[1],": ",ROC_auc[1]),hjust=1) +
    annotate("text",x=0.97,y=0.1,label=paste0(names(Listpred)[2],": ",ROC_auc[2]),hjust=1) +
    annotate("text",x=0.97,y=0.05,label=paste0(names(Listpred)[3],": ",ROC_auc[3]),hjust=1) +
    theme(legend.position="none", plot.title=element_text(vjust=2,hjust = 0.5)) +
    labs(title=title)+
    theme_bw()
}

compute_SNR<-function(K, indexmissing){
  H=indexmissing ; p=ncol(K)
  O=(1:p)[-H]
  num=norm(K[O,H]%*%K[H,O]/K[H,H],type='2')^2
  denom=norm(K[O,O],type='2')^2
  return(num/denom)
}
amplify_cor<-function(K,indexmissing,eps){
  H=indexmissing ; p=ncol(K)
  O=(1:p)[-H]
  newK=eps*K
  newK[O,O]=K[O,O]
  newK[H,H]=eps*K[H,H]
  return(newK)
}
amplify_diag<-function(K,v){
  newK<-K+diag(v, ncol(K))
  return(newK)
}
setEpsi<-function(K,indexmissing, plot=FALSE){
  eps<-1
  v<-(-0.1)
  L=list(c(compute_SNR(K,indexmissing),eps,v))
  print(min(eigen(K)$values))
  
  while(compute_SNR(K,indexmissing)<1){
    
    if(min(eigen(K)$values)>0){
      
      while(min(eigen(K)$values)>0){
        eps=eps+0.01
        K=amplify_cor(K,indexmissing,eps)
      }
      
      L=list.append(L,c(compute_SNR(K,indexmissing), eps, v))
      
    }else{
      
      while(min(eigen(K)$values)<=0){
        v=v+0.01
        K=amplify_diag(K,v)
      }
      
      L=list.append(L,c(compute_SNR(K,indexmissing), eps, v))
    }
    
  }
  L=do.call(rbind,L)
  colnames(L)=c("SNR","Epsilon","Lambda")
  cat(paste0("\nfinal SNR=",round(compute_SNR(K,indexmissing),3),", final min eig ",min(eigen(K)$values),", for eps=",eps," and v=",v))
  if(plot){
    g= L%>% as_tibble() %>% gather(parameter,value,-SNR) %>% 
      ggplot(aes(value,SNR))+geom_point()+geom_line()+facet_wrap(~parameter,scales="free")+
      theme_light()
    print(g)
  }
  return(list(K=K,values=L))
}

gener.data<-function(p=20,n=200,counts=FALSE, type="scale-free", v=0.001,plot=TRUE){
  data=data_from_scratch(type = type,p = p,n = n,signed = TRUE,prob = 5/p,v = v)
  omega=data$omega
  
  
  hidden=which.max(diag(omega)) #on cache le noeud de plus fort degré
  omega=setEpsi(omega,hidden, plot=TRUE)$K
  sigma=solve(omega)
  # les voisins du noeuds qu'on cache
  trueClique=which(omega[hidden,-hidden]!=0)
  
  #comptages ou non
  if(counts){
    counts=data$data
    counts_obs=counts[,-hidden]
    sigma_obs=PLN(counts_obs~1)$model_par$Sigma
  }else{
    data=rmvnorm(n,sigma=sigma)
    data_obs=data[,-hidden]
    sigma_obs=cov(data_obs)
  }
  omega_obs=solve(sigma_obs)
  if(plot){
    G=draw_network(abs(omega),groupes=1*(diag(omega)==diag(omega)[hidden]), 
                   layout="nicely",curv=0,nb=2,pal="black",nodes_label = 1:p)$G
    print(G)
  }
  return(list(sigmaO=sigma_obs, omegaO=omega_obs,omega=omega,clique=trueClique, hidden=hidden))
}
```

