---
title: "Comparaison de deux formules"
output: 
  html_document:
    toc: true
    toc_float: true
---





Formule obtenue théorique, avec $ \varphi_{jk} = \Big(1-\frac{\omega_{jk}^2}{\omega_{jj}\omega_{kk}}\Big)^{n/2}$:

$$ \widetilde{\beta}_{jk} = \beta_{jk}\varphi_{jk} \times \exp\Big(-\frac{1}{2} \omega_{jk}[\widetilde{M}_O^T \widetilde{M}_O]_{jk}\Big)$$
$$ \widetilde{\beta}_{kh} = \beta_{kh}\varphi_{kh} \times\exp\Big(-\frac{1}{2} \omega_{kh}[\widetilde{M}_H^T \widetilde{M}_O]_{kh}\Big)$$
Formules intuitée dans les simulations:

*Idée 1:*
Valeur absolue dans l'exponentielle:
$$ \widetilde{\beta}_{jk} =\beta_{jk}\varphi_{jk} \times\exp\Big(|-\frac{1}{2} \omega_{jk}[\widetilde{M}_O^T \widetilde{M}_O]_{jk}|\Big)$$


*Idée 2:*
Diviser par $\varphi$ et $\beta$:

$$ \widetilde{\beta}_{jk} = \frac{1}{\beta_{jk}\varphi_{jk}} \times \exp\Big(-\frac{1}{2} \omega_{jk}[\widetilde{M}_O^T \widetilde{M}_O]_{jk}\Big)$$

*Idée 3:*
Diviser par $\varphi$ et $\beta$ avec valeur absolue supplémentaire:

$$ \widetilde{\beta}_{jk} =\frac{1}{\beta_{jk}\varphi_{jk}}\times\exp\Big(|-\frac{1}{2} \omega_{jk}[\widetilde{M}_O^T \widetilde{M}_O]_{jk}|\Big)$$
*Idée 4:*
Diviser par $\varphi$ :

$$ \widetilde{\beta}_{jk} =\frac{\beta_{jk}}{\varphi_{jk}}\times\exp\Big(-\frac{1}{2} \omega_{jk}[\widetilde{M}_O^T \widetilde{M}_O]_{jk}\Big)$$

```{r, eval=FALSE }
computeWg<-function(phi,omega,W,MH,MO, alpha, form="theory"){
  p=ncol(MO) ; r=ncol(MH)
  O = 1:p ; H = (p+1):(p+r)
  psi=phi^(n*alpha*0.5)
  Wg<-matrix(0,(p+r),(p+r))
  if(form=="theory"){
    browser()
   logWg[O,O]<-log(W[O,O])+log(psi[O,O])-0.5*alpha*omega[O,O]*(t(MO)%*%MO)
   logWg[O,H]<-log(W[O,H])+log(psi[O,H])-alpha*omega[O,H]*(t(MH)%*%MO)
  }
  if(form=="id1"){
    
    logWg[O,O]<-log(W[O,O])+log(psi[O,O])+abs(-0.5*alpha*omega[O,O]*(t(MO)%*%MO))
    logWg[O,H]<-log(W[O,H])+log(psi[O,H])+abs(-alpha*omega[O,H]*(t(MH)%*%MO))
  }
  
  if(form=="id2"){
    logWg[O,O]<- -0.5*alpha*omega[O,O]*(t(MO)%*%MO)-log(W[O,O])-log(psi[O,O])
    logWg[O,H]<- -alpha*omega[O,H]*(t(MH)%*%MO)-log(W[O,H]) -log(psi[O,H])
  }
  if(form=="id3"){
    logWg[O,O]<- abs(-0.5*alpha*omega[O,O]*(t(MO)%*%MO))-log(W[O,O])-log(psi[O,O])
    logWg[O,H]<- abs(-alpha*omega[O,H]*(t(MH)%*%MO))-log(W[O,H])-log(psi[O,H]) 
  }
  if(form=="id4"){
  #  browser()
    logWg[O,O]<-log(W[O,O]) -0.5*alpha*omega[O,O]*(t(MO)%*%MO)-log(psi[O,O])
    logWg[O,H]<-log(W[O,H]) -alpha*omega[O,H]*(t(MH)%*%MO)-log(psi[O,H])
  }
  
  logWg[H,O]<-t(logWg[O,H])
  diag(logWg) = 0
 # shrinking and centering
  gamma=logWg[O,H]
  gamma[which(gamma<(-30))]=-30
  gamma=gamma-mean(gamma)
  gamma[which(gamma>10)]=10
  Wg[O,H]=exp(gamma)
  Wg[H,O]<-t(Wg[O,H])
  gamma=F_Sym2Vec(logWg[O,O])
  gamma[which(gamma<(-30))]=-30
  gamma=gamma-mean(gamma)
  gamma[which(gamma>max(log(Wg[O,H])))]=max(log(Wg[O,H]))
  Wg[O,O]=exp(F_Vec2Sym(gamma))
  
  diag(Wg) = 1
  
  return(Wg)
}
```


```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(EMtree)
library(PLNmodels)
library(LITree)
library(ggraph)
library(tidygraph)
library(tidyverse)
library(mvtnorm)
library(useful)
library(mclust)
library(MASS)
library(reshape2)#for ggimage
library(gridExtra)
source("/Users/raphaellemomal/these/R/codes/missingActor/fonctions-missing.R")
#source("/Users/raphaellemomal/these/R/codes/missingActor/VEMtree.R")
mytheme <- list(theme_light(), scale_fill_brewer(palette="Dark2"))
```
 

# Data simulation

```{r, echo=FALSE}
generator_PLN<-function(Sigma,covariates=NULL, n=50){
  # ajout d'une constante, pa rapport à EMtree::generator_PLN
  p<-ncol(Sigma)
  if(!is.null(covariates)){
    n<-nrow(covariates)
    c<-ncol(covariates)
    string<-paste0("~", paste(colnames(covariates), collapse=" + "))
    formula<-as.formula(string)
    m<- model.matrix(formula,covariates)[,-1]
    mc<-ncol(m)
    beta<-matrix(runif(p*mc),mc,p)
    prod=m %*% beta+2
  }else{
    prod=2
  }
  Z<- rmvnorm(n, rep(0,nrow(Sigma)), Sigma)
  Y = matrix(rpois(n*p, exp(Z+prod )), n, p)
  return(Y)
}

generator_param<-function(G,signed=FALSE,v=0){
  lambda = 1;  p=ncol(G);  sumlignes=rowSums(matrix(G,p,p));  D=diag(sumlignes+v)
  if(signed){
    Gsign = F_Vec2Sym(F_Sym2Vec(G * matrix(2*rbinom(p^2, 1, .3)-1, p, p)))
    omega = lambda*D - Gsign
    while(min(eigen(omega)$values) < 1e-10 & lambda<1e3){
      lambda = 1.1*lambda
      omega = lambda*D - Gsign
    }
  }else{
    omega = lambda*D + G
    while (min(eigen(omega)$values) < 1e-10){
      lambda = 1.1*lambda
      omega =lambda*D + G
    }
  }
  sigma = cov2cor(solve(omega))
  sim=list(sigma=sigma,omega=omega,cste=lambda)
  return(sim)
}
data_from_scratch<-function(type, p=20,n=50, r=5, covariates=NULL,
                            prob=log(p)/p,dens=log(p)/p,
                            signed=FALSE,v=0,draw=FALSE){
  # make graph
  graph<- generator_graph(graph=type,p=p,prob=prob,dens=dens,r=r)
  param<-generator_param(G=as.matrix(graph),signed=signed,v=v)
  data<-generator_PLN(param$sigma,covariates,n)
  if(draw){
    g=as_tbl_graph(as.matrix(graph)) %>%
      ggraph(layout="nicely")+
      geom_edge_link()+
      geom_node_point(size=2, color="blue")
    print(g)
  }
  
  return(list(data=data,omega= param$omega))
}
```

```{r}
# simu parameters
set.seed(7)
n=200
p=14
r=1
type="scale-free"
plot=TRUE

################
#----- DATA
# simulate graph and omega, then sigma0 and finally counts
data=data_from_scratch(type = type,p = p+r,n = n,signed = FALSE,prob = 5/p,v = 0)
omega=data$omega
# on cache les r plus gros
hidden=which(diag(omega)%in%sort(diag(omega), decreasing = TRUE)[1:r])[1:r] 
trueClique=which(omega[hidden,-hidden]!=0)
if(plot){
  G=draw_network(1*(omega!=0),groupes=1*(diag(omega)==diag(omega)[hidden][1]),
                 layout="nicely",curv=0,nb=2,pal="black",nodes_label = 1:(p+r))$G
  print(G)
}
 
sigmaO=(solve(omega))[-hidden,-hidden]
melt(sigmaO) %>% as_tibble() %>% mutate(diag=(Var1==Var2))%>% ggplot(aes(value, fill=diag))+geom_histogram(binwidth = 0.05)+mytheme


```

```{r}
ome_init=omega[c(2:15,1),c(2:15,1)]#ome is for testing
ome=ome_init
diag(ome)=0

####################
#----- PLN on counts
# optimization of theta and h(Z_O)
counts=generator_PLN(sigmaO,covariates = NULL,n=n)
PLNfit<-PLN(counts~1)
MO<-PLNfit$var_par$M # MiO = ith row of MO
SO<-PLNfit$var_par$S # SiO = diag(ith row of SO)
sigma_obs=PLNfit$model_par$Sigma
melt(sigma_obs) %>% as_tibble() %>% mutate(diag=(Var1==Var2))%>% ggplot(aes(value, fill=diag))+geom_histogram(binwidth = 0.1)+mytheme

data.frame(cbind(melt(sigma_obs)[,"value"],melt(sigmaO)[,"value"])) %>% 
  ggplot(aes(X1,X2))+geom_point()+geom_abline()+labs(x="sigma hat",y="sigma")+mytheme

```

# Initialisation

```{r}
# whole Z
# initviasigma=init.mclust(sigma_obs,title="Sigma",trueClique = trueClique,n.noise=p*3+5)
# initial.param<-initEM(sigma_obs,n=n,cliquelist = list(initviasigma),pca=TRUE) # quick and dirty modif for initEM to take a covariance matrix as input
# omega_init=initial.param$K0
# sigma_init=initial.param$Sigma0

# Tree
O=1:p
Wg_init <- matrix(1, p+r, p+r); diag(Wg_init) = 0; Wg_init =Wg_init / sum(Wg_init)
W_init <- matrix(1, p+r, p+r); diag(W_init) = 0;# W_init =W_init / sum(W_init)
W_init[O,O] <- EMtree_corZ(cov2cor(sigma_obs),n = n,maxIter = 20)$edges_weight


```


# Inference

## Formule Théorique


```{r pressure}
resVe.Th=VE(MO ,SO,MH = matrix(100,n,r),sigma_obs,ome_init,W_init,Wg_init,maxIter=150,eps=1e-3, plot=TRUE, 
         form="theory",alpha=0.8)
resVe.Th$Hmeans[,15]
ggimage(resVe.Th$Gprobs)
```

## Formule essai

```{r}
resVe.id1=VE(MO,SO,MH = matrix(100,n,r),sigma_obs,ome_init,W_init,Wg_init,maxIter=150,eps=1e-3, plot=TRUE, 
        form="id1",alpha=0.8)

```


```{r}
resVe.id2=VE(MO,SO,MH = matrix(100,n,r),sigma_obs,ome_init,W_init,Wg_init,maxIter=150,eps=1e-3, plot=TRUE, 
         form="id2",alpha=0.8)

```

```{r}
resVe.id3=VE(MO,SO,MH = matrix(100,n,r),sigma_obs,ome_init,W_init,Wg_init,maxIter=150,eps=1e-3, plot=TRUE, 
         form="id3",alpha=0.8)

```

```{r}
resVe.id4=VE(MO,SO,MH = matrix(100,n,r),sigma_obs,ome_init,W_init,Wg_init,maxIter=150,eps=1e-3, plot=TRUE, 
         form="id4",alpha=0.8)

```

 
# Comparaison

TPR : True Positive Rate = TP/(TP+FN)
PPV : Positive Predictive value  = TP/(TP+FP)

Quantités calculées en séparant les O et les H.

## Formule Théorique

```{r, echo=FALSE}
h=15
seuil=0.5
performance=accppvtpr(resVe.Th$Gprobs,ome,h,seuil)
Acc=performance[1] ;AccH=performance[2] ;AccO=performance[3] 
PPV=performance[4] ;PPVH=performance[5] ; PPVO=performance[6]
TPR=performance[7] ;TPRH=performance[8] ;TPRO=performance[9] 
p1<-ggimage(resVe.Th$Gprobs)+labs(title=paste0("G hat (thresh=",seuil,")"))
p2<-ggimage(ome)+labs(title="G")
grid.arrange(p1,p2,ncol=2, top=paste0("Tpr=",TPR," (TprO=",TPRO," , TprH=",TPRH,
                                      ")\n Ppv=",PPV," (PpvO=",PPVO," , PpvH=",PPVH,")"))

```

## Formules essais

### id1 : valeur absolue:

```{r,echo=FALSE}
performance=accppvtpr(resVe.id1$Gprobs,ome,h,seuil)
Acc=performance[1] ;AccH=performance[2] ;AccO=performance[3] 
PPV=performance[4] ;PPVH=performance[5] ; PPVO=performance[6]
TPR=performance[7] ;TPRH=performance[8] ;TPRO=performance[9] 
p1<-ggimage(resVe.id1$Gprobs)+labs(title=paste0("G hat (thresh=",seuil,")"))
p2<-ggimage(ome)+labs(title="G")
grid.arrange(p1,p2,ncol=2, top=paste0("Tpr=",TPR," (TprO=",TPRO," , TprH=",TPRH,
                                      ")\n Ppv=",PPV," (PpvO=",PPVO," , PpvH=",PPVH,")"))


```

### id2 : inversion phi et beta:

```{r,echo=FALSE}
performance=accppvtpr(resVe.id2$Gprobs,ome,h,seuil)
Acc=performance[1] ;AccH=performance[2] ;AccO=performance[3] 
PPV=performance[4] ;PPVH=performance[5] ; PPVO=performance[6]
TPR=performance[7] ;TPRH=performance[8] ;TPRO=performance[9] 
p1<-ggimage(resVe.id2$Gprobs)+labs(title=paste0("G hat (thresh=",seuil,")"))
p2<-ggimage(ome)+labs(title="G")
grid.arrange(p1,p2,ncol=2, top=paste0("Tpr=",TPR," (TprO=",TPRO," , TprH=",TPRH,
                                      ")\n Ppv=",PPV," (PpvO=",PPVO," , PpvH=",PPVH,")"))


```

 
### id3 : inversion et valeur absolue:

```{r,echo=FALSE}
performance=accppvtpr(resVe.id3$Gprobs,ome,h,seuil)
Acc=performance[1] ;AccH=performance[2] ;AccO=performance[3] 
PPV=performance[4] ;PPVH=performance[5] ; PPVO=performance[6]
TPR=performance[7] ;TPRH=performance[8] ;TPRO=performance[9] 
p1<-ggimage(resVe.id3$Gprobs)+labs(title=paste0("G hat (thresh=",seuil,")"))
p2<-ggimage(ome)+labs(title="G")
grid.arrange(p1,p2,ncol=2, top=paste0("Tpr=",TPR," (TprO=",TPRO," , TprH=",TPRH,
                                      ")\n Ppv=",PPV," (PpvO=",PPVO," , PpvH=",PPVH,")"))


```

 
### id5 : multiplication -n/2:

```{r,echo=FALSE}
performance=accppvtpr(resVe.id4$Gprobs,ome,h,seuil)
Acc=performance[1] ;AccH=performance[2] ;AccO=performance[3] 
PPV=performance[4] ;PPVH=performance[5] ; PPVO=performance[6]
TPR=performance[7] ;TPRH=performance[8] ;TPRO=performance[9] 
p1<-ggimage(resVe.id4$Gprobs)+labs(title=paste0("G hat (thresh=",seuil,")"))
p2<-ggimage(ome)+labs(title="G")
grid.arrange(p1,p2,ncol=2, top=paste0("Tpr=",TPR," (TprO=",TPRO," , TprH=",TPRH,
                                      ")\n Ppv=",PPV," (PpvO=",PPVO," , PpvH=",PPVH,")"))


```
