---
title: "Choisir la meilleure initialisation"
output: 
  html_document:
    theme: cosmo
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
library(tidyverse)
library(kableExtra)
mytheme.dark <-function(legend){list= list(theme_light(), scale_color_brewer(legend,palette="Dark2"), scale_fill_brewer(legend,palette="Dark2"),
                                           theme(strip.background=element_rect(fill="gray50",colour ="gray50"),
                                                 plot.title = element_text(hjust = 0.5)))
return(list)}

seed_filtre=readRDS("/Users/raphaellemomal/these/R/codes/missingActor/SimResults/seed_filtre_eigtol_1e-6.rds")
seed_filtre=seed_filtre %>% mutate(filtre=as.factor(ifelse(filtre, "GEM", "VEM")))
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```

La génération de points de départs du VEM est faite par ACP creuse (`sparsePCA`). Un rééchantillonnage par bootstrap permet de générer plusieurs initialisations, qu'il faut ensuite départager.

De manière classique, le choix se fait sur la borne inférieure de la vraisemblance du modèle, `J`. Mais dans certains cas le modèle avec la meilleure valeur de `J` ne permet pas de reconstruire l'acteur manquant. On observe le cas échéant de faibles valeurs de précision pour la partie cachée du réseau (notée PPVH), et d'AUC.

Dans ce document on compare le comportement de deux graphs (seed 1 et seed 19), le premier pour lequel la sélection d'initialisation classique fonctionne, l'autre pas.


Techniquement pour ces deux exemples le nombre d'échantillons bootstrap B est fixé à 1e+4. Pour chaque clique initiale, on a lancé VEMtree dans sa version basique et dans sa version GEM, où la mise à jour des $\widetilde{\beta}$ et de la diagonale de $\Omega$ est conditionnée à l'augmentation de `J`.

# Borne inf `J` {.tabset}

Performances atteintes par le modèle présentant la valeur maximale de `J` pour chaque graphe dans les deux versions de l'algorithme :

```{r,echo=FALSE}
seed_filtre %>%  group_by(seed, filtre) %>% mutate(maxJ = max(J)) %>% 
  filter(J==maxJ) %>% dplyr::select(seed, filtre,maxJ, AUC, ppvh) %>% mutate(AUC=cell_spec(AUC,"html", color = ifelse(AUC < 0.5, "red"," black")),  ppvh=cell_spec(ppvh,"html", color = ifelse(ppvh < 0.5, "red"," black")))%>% kable(escape=FALSE, format="html", align=c("ccrrr")) %>% 
  collapse_rows()%>% kable_styling()
```
Répartition de `J`en fonction des performances AUC et PPVH :

## AUC

```{r }
seed_filtre %>% ggplot(aes( AUC,J))+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+
  geom_point()+
  facet_grid(filtre~seed)+mytheme.dark("")
```

## PPVH
```{r}
seed_filtre %>% ggplot(aes( ppvh,J))+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+
  geom_point()+
  facet_grid(filtre~seed)+mytheme.dark("")
```

## GEM/VEM
```{r}
seed_filtre %>% dplyr::select(J,filtre,index,seed) %>% 
  spread(filtre,J) %>% 
  ggplot(aes(VEM, GEM))+geom_point()+facet_wrap(~seed)+geom_abline()+
  mytheme.dark("") 
```

#  `JPLN_Eg` {.tabset}
Le modèle PLN est estimé par `PLNmodels` de manière variationnelle et maximise une borne inf `JPLN`. L'utilisation de `JPLN` dans notre algorithme amène à faire l'hypothèse que $E_{gh}[\log p(Z_O|T)] \approx E_h[\log p(Z_O)]$, ce qui revient à négliger la structure de dépendance par arbre et à supposer que $E_g[\Omega_{Tm}] \approx \widetilde{\Sigma}_O^{-1} \approx \Sigma_O^{-1}$. Ces approximations permettent d'utiliser les estimateurs de $\theta$, $M$ et $S$ obtenus avec `PLNmodels`.

La variable `JPLN_Eg` stocke la partie de la borne inf de PLN évaluée avec l'espérance sous $g$ de $\Omega_{Tm}$, soit $JPLN_{Eg} = \frac{n}{2} \log |E_g[\Omega_{Tm}]| - \frac{1}{2}Tr(E_h[Z_O^T Z_O].E_g[\Omega_{Tm}])$. Dans la suite on utilisera aussi `JPLN_SigT`, la valeur de `JPLN` maximale, obtenue avec $\widetilde{\Sigma}_O = \frac{1}{n} E_h[Z_O^TZ_O]$ : $JPLN_{\widetilde{\Sigma}_O} = -\frac{n}{2} \log |\widetilde{\Sigma}_O| - \frac{1}{2}Tr(E_h[Z_O^T Z_O] . \widetilde{\Sigma}_O^{-1})$

## AUC

```{r}
seed_filtre %>% ggplot(aes(AUC, JPLN_EgOm))+geom_point()+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+
  facet_grid(filtre~seed)+mytheme.dark("")+labs(y="JPLN_Eg")
```

## PPVH

```{r}
seed_filtre %>% ggplot(aes(ppvh, JPLN_EgOm))+geom_point()+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+labs(y="JPLN_Eg")+
  facet_grid(filtre~seed)+mytheme.dark("")
```


#Différence entre `JPLN_Eg` et  `JPLN_SigT`  {.tabset}
`diffJPLN` quantifie l'écart entre `JPLN_Eg` et `JPLN_SigT`.

```{r}
seed_filtre=seed_filtre %>% mutate(diffJPLN=JPLN_SigT-JPLN_EgOm) 
seed_filtre %>% group_by(seed) %>% summarise(JPLN_SigT = JPLN_SigT[1]) %>% kable()%>% 
  collapse_rows() %>%
  kable_styling()
```

## AUC

```{r} 
 seed_filtre %>% ggplot(aes(AUC, diffJPLN))+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+geom_point()+
  facet_grid(filtre~seed)+mytheme.dark("")
```

## PPVH

```{r}
seed_filtre %>% ggplot(aes(ppvh, diffJPLN))+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+geom_point()+
  facet_grid(filtre~seed)+mytheme.dark("")
```


# Delta{.tabset}

Delta est la norme de Frobenius de la différence entre les matrices $\widetilde{\Sigma}_O^{-1}$ et $E_g[ \Omega_{Tm}] = (P_g.\Omega)_m + diag(\Omega_m)$ :
$$\Delta = ||\widetilde{\Sigma}_O^{-1} - E_g[ \Omega_{Tm}]   ||_F $$Plus Delta est petit, plus l'utilisation de `PLNmodels` en amont de VEMtree est juste, c'est à dire que l'utilisation d'estimateurs de $M_O$ et de $S_O$ négligeant une dépendance par arbre a un faible effect dans la suite de l'optimisation.


## diffJPLN

```{r}
# seed_filtre %>% ggplot(aes( diffJPLN,Delta, color=(AUC>0.7 & ppvh > 0.7)))+geom_point()+
#   facet_grid(filtre~seed)+mytheme.dark("AUC>0.7\net\nPPVH>0.7")

```

##AUC

```{r,echo=FALSE}
# seed_filtre %>% ggplot(aes( AUC,Delta))+geom_point()+
#   geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+
#   facet_grid(filtre~seed)+mytheme.dark("")
```

##PPVH

```{r,echo=FALSE}
# seed_filtre %>% ggplot(aes( ppvh,Delta))+geom_point()+
#   geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+
#   facet_grid(filtre~seed)+mytheme.dark("")

```


## GEM/VEM

```{r,echo=FALSE}
# seed_filtre %>% dplyr::select(Delta,filtre,index,seed) %>% 
#   spread(filtre,Delta) %>% 
#   ggplot(aes(VEM, GEM))+geom_point()+facet_wrap(~seed)+geom_abline()+
#   mytheme.dark("") 
```

# `Jcor`: correction de la borne inf {.tabset} 

`J` peut être corrigée de cette approximation :
$$J_{cor} = J + diffJPLN$$.

```{r,echo=FALSE}
seed_filtre=seed_filtre %>% mutate(Jcor = J+diffJPLN)
seed_filtre %>%  group_by(seed, filtre) %>% mutate(maxJcor = max(Jcor)) %>%   filter(Jcor==maxJcor) %>% dplyr::select(seed, filtre,maxJcor, AUC, ppvh) %>% mutate(AUC=cell_spec(AUC,"html", color = ifelse(AUC < 0.5, "red"," black")),  ppvh=cell_spec(ppvh,"html", color = ifelse(ppvh < 0.5, "red"," black")))%>% kable(escape=FALSE, format="html",caption="Sélection avec J corrigée",align=c("ccrrr"))%>% 
  collapse_rows() %>% kable_styling()
```

## `J`

```{r,echo=FALSE}

seed_filtre %>% ggplot(aes(J,Jcor, color=(AUC>0.5&ppvh>0.5)))+geom_point()+
  facet_grid(filtre~seed)+mytheme.dark("(AUC,PPVH)>0.5")
```

##AUC 

```{r,echo=FALSE}
seed_filtre %>% ggplot(aes(AUC,Jcor))+geom_point()+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+
  facet_grid(filtre~seed)+mytheme.dark("")
```

##PPVH 

```{r,echo=FALSE}
seed_filtre %>% ggplot(aes(ppvh,Jcor))+geom_point()+
  geom_vline(xintercept = 0.5, linetype="dashed", color="orange")+
  facet_grid(filtre~seed)+mytheme.dark("")
```


## GEM/VEM

```{r}
seed_filtre %>% dplyr::select(Jcor,filtre,index,seed) %>% 
  spread(filtre,Jcor) %>% 
  ggplot(aes(VEM, GEM))+geom_point()+facet_wrap(~seed)+geom_abline()+
  mytheme.dark("") 
```

# Sous-sélection des bornes inf {.tabset}

Comparaison de la sélection du modèle avec la meilleure `J`ou la meilleure `Jcor`, parmi les petites valeures de diffJPLN (inférieures au quantile 30%) ou parmi les petites valeures de Delta (inférieures au quantile 10%).

## Par `diffJPLN` : tab

```{r, echo=FALSE}
seed_filtre=seed_filtre %>% group_by(seed,filtre) %>% mutate(qdiff = quantile(diffJPLN,0.3), gooddiff = diffJPLN<qdiff) %>%  ungroup()
```

```{r,echo=FALSE}
seed_filtre %>%filter(gooddiff) %>%   group_by(seed, filtre) %>% mutate(maxJ = max(J)) %>%   filter(J==maxJ) %>% dplyr::select(seed, filtre,maxJ, AUC, ppvh) %>% mutate(AUC=cell_spec(AUC,"html", color = ifelse(AUC < 0.5, "red"," black")),  ppvh=cell_spec(ppvh,"html", color = ifelse(ppvh < 0.5, "red"," black"))) %>% kable(escape=FALSE,format="html",caption="Sélection avec J", align=c("ccrrr"))%>% 
  collapse_rows() %>% kable_styling()
```

```{r,echo=FALSE}
seed_filtre %>%filter(gooddiff) %>%   group_by(seed, filtre) %>% mutate(maxJcor = max(Jcor)) %>%   filter(Jcor==maxJcor) %>% dplyr::select(seed, filtre,maxJcor, AUC, ppvh) %>% mutate(AUC=cell_spec(AUC,"html", color = ifelse(AUC < 0.5, "red"," black")),  ppvh=cell_spec(ppvh,"html", color = ifelse(ppvh < 0.5, "red"," black")))%>% kable(escape=FALSE, format="html",caption="Sélection avec J corrigée",align=c("ccrrr"))%>% 
  collapse_rows() %>% kable_styling()
```

## Par `diffJPLN` : graphes

AUC :

```{r}
seed_filtre %>% ggplot(aes( AUC,Jcor, color=(gooddiff)))+geom_point()+
  geom_vline(xintercept = 0.5, linetype="dashed", color="gray")+
  facet_grid(filtre~seed) + mytheme.dark("diffJPLN < q30(diffJPLN)")
```

PPVH :

```{r}
seed_filtre %>% ggplot(aes( ppvh,Jcor, color=(gooddiff)))+geom_point()+
  geom_vline(xintercept = 0.5, linetype="dashed", color="gray")+
  facet_grid(filtre~seed) + mytheme.dark("diffJPLN < q30(diffJPLN)")
```

## Par `Delta` : tab

```{r, echo=FALSE}
# seed_filtre=seed_filtre %>% group_by(seed,filtre) %>% mutate(medDelta = quantile(Delta,0.1),  goodDelta = Delta<medDelta) %>%  ungroup()

```

```{r,echo=FALSE}
# seed_filtre %>%filter(goodDelta) %>%   group_by(seed, filtre) %>% mutate(maxJ = max(J)) %>%   filter(J==maxJ) %>% dplyr::select(seed, filtre,maxJ, AUC, ppvh) %>% kable(escape=FALSE, format="html",caption="Sélection avec J",align=c("ccrrr"))%>% 
#   collapse_rows() %>% kable_styling()
```

```{r,echo=FALSE}
# seed_filtre %>%filter(goodDelta) %>%   group_by(seed, filtre) %>% mutate(maxJcor = max(Jcor)) %>%   filter(Jcor==maxJcor) %>% dplyr::select(seed, filtre,maxJcor, AUC, ppvh)  %>% kable(escape=FALSE,format="html",caption="Sélection avec J corrigée",align=c("ccrrr")) %>% 
#   collapse_rows()%>% kable_styling()
```

## Par `Delta : graphes
AUC :
```{r}
# seed_filtre %>% ggplot(aes( AUC,Jcor, color=(goodDelta)))+geom_point()+
#   geom_vline(xintercept = 0.5, linetype="dashed", color="gray")+
#   facet_grid(filtre~seed) + mytheme.dark("Delta < q10(Delta)")

```

PPVH : 

```{r}
# seed_filtre %>% ggplot(aes( ppvh,Jcor, color=(goodDelta)))+geom_point()+
#   geom_vline(xintercept = 0.5, linetype="dashed", color="gray")+
#   facet_grid(filtre~seed) + mytheme.dark("Delta < q10(Delta)")
```

 
# Courbes de saturation {.tabset}

mxJcor sature bien avant maxJ:

## max Jcor

```{r}
seed_filtre %>% dplyr::select(Jcor, seed, filtre, index) %>% as_tibble() %>% group_by(seed, filtre) %>% 
  mutate(maxJcor = purrr::map(index, function(x){max(Jcor[1:x])})) %>% unnest() %>% ungroup() %>%
  ggplot(aes(index, maxJcor, color=filtre))+geom_point()+geom_line()+
  mytheme.dark("")+facet_wrap(~seed, scales="free_x")+
  labs(title="B=1e+4", x="x premières cliques uniques")

```


## max J

```{r}
seed_filtre %>% dplyr::select(J, seed, filtre, index) %>% as_tibble() %>% group_by(seed, filtre) %>% 
  mutate(maxJ = purrr::map(index, function(x){max(J[1:x])})) %>% unnest() %>% ungroup() %>%
  ggplot(aes(index, maxJ, color=filtre))+geom_point()+geom_line()+
  mytheme.dark("")+facet_wrap(~seed, scales="free_x")+
  labs(title="B=1e+4", x="x premières cliques uniques")

```

## nb cliques

```{r}

cliques_spca19=readRDS("/Users/raphaellemomal/these/R/codes/missingActor/SimResults/cliques_spca19_10000.rds")
cliques_spca1=readRDS("/Users/raphaellemomal/these/R/codes/missingActor/SimResults/cliques_spca1_10000.rds")
plotdata=tibble(index=1:10000, cli19=cliques_spca19$cliqueList,cli1=cliques_spca1$cliqueList) %>% 
  mutate(seed1 = purrr::map(index, function(x){length(unique(cli1[1:x]))}),
         seed19 = purrr::map(index, function(x){length(unique(cli19[1:x]))})) %>% unnest() %>% dplyr::select(seed1, seed19,index) %>% gather(key, value, -index)

plotdata %>% 
  ggplot(aes(index, value, color=key))+geom_point(size=0.3)+geom_line(size=0.1)+ mytheme.dark("")+
  labs(title="Nouvelles cliques découvertes, B=1e+4", y="nombre de cliques uniques")

```

## Zoom nb cliques

```{r}
plotdata %>% 
  ggplot(aes(index, value, color=key))+geom_point(size=0.3)+geom_line()+ mytheme.dark("")+
  coord_cartesian(xlim=c(0,200), ylim=c(0,85))+
  labs(title="Zoom sur les 200 premiers échantillons bootstrap", y="nombre de cliques uniques")
```

# Points sensibles

- tolérance pour la projection nearPD
- projeter en cours d'algo ?
- 